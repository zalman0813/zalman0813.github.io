<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>medium on Pin Code Blog</title><link>https://zalman0813.github.io/tags/medium/</link><description>Recent content in medium on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 26 Mar 2023 09:19:39 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/medium/index.xml" rel="self" type="application/rss+xml"/><item><title>198. House Robber</title><link>https://zalman0813.github.io/posts/house-robber/</link><pubDate>Sun, 26 Mar 2023 09:19:39 +0800</pubDate><guid>https://zalman0813.github.io/posts/house-robber/</guid><description>Link: https://leetcode.com/problems/house-robber/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(1) class Solution: def rob(self, nums: List[int]) -&amp;gt; int: rob1, rob2 = 0, 0 #[rob1, rob2, n, n+1, ...] for n in nums: temp = max(n + rob1, rob2) rob1 = rob2 rob2 = temp return rob2 # top-down by recursive, which will be timeout #Time Complexity: O(n) #Space Complexity: O(n) class Solution: def rob(self, nums: List[int]) -&amp;gt; int: dp = [0]*len(nums) def helper(i, nums, dp): if i &amp;gt;= len(nums): return 0 if dp[i] == 0: rob = helper(i+2, nums, dp) + nums[i] not_rob = helper(i+1, nums, dp) dp[i] = max(rob, not_rob) return dp[i] return helper(0, nums, dp)</description></item><item><title>62. Unique Paths</title><link>https://zalman0813.github.io/posts/unique-paths/</link><pubDate>Sat, 25 Mar 2023 18:24:21 +0800</pubDate><guid>https://zalman0813.github.io/posts/unique-paths/</guid><description>Link: https://leetcode.com/problems/unique-paths/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(m*n) #Space Complexity: O(m) class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: col = [1]*m for i in range(n-1): newCol = [1]*m for j in range(m - 2, -1, -1): newCol[j] = newCol[j+1] + col[j] col = newCol return col[0]</description></item><item><title>509. Fibonacci Number</title><link>https://zalman0813.github.io/posts/fibonacci-number/</link><pubDate>Sat, 25 Mar 2023 16:53:42 +0800</pubDate><guid>https://zalman0813.github.io/posts/fibonacci-number/</guid><description>Link: https://leetcode.com/problems/fibonacci-number
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(n) class Solution: def fib(self, n: int) -&amp;gt; int: if n == 0: return 0 if n == 1: return 1 dp = [0] * (n + 1) dp[0] = 0 dp[1] = 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] #Time Complexity: O(n) #Space Complexity: O(1) class Solution: def fib(self, n: int) -&amp;gt; int: if n == 0: return 0 if n == 1: return 1 prev_2 = 0 prev_1 = 1 for i in range(2, n+1): tmp = prev_1 + prev_2 prev_2 = prev_1 prev_1 = tmp return prev_1</description></item><item><title>518. Coin Change Ii</title><link>https://zalman0813.github.io/posts/coin-change-ii/</link><pubDate>Sat, 25 Mar 2023 16:21:41 +0800</pubDate><guid>https://zalman0813.github.io/posts/coin-change-ii/</guid><description>Link: https://leetcode.com/problems/coin-change-ii/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*c), where c is amount #Space Complexity: O(n*c) class Solution: def change(self, amount: int, coins: List[int]) -&amp;gt; int: if amount == 0: return 1 dp = [[1 for j in range(len(coins))] for i in range(amount+1) ] for amt in range(1, amount+1): for j in range(len(coins)): x = 0 if amt - coins[j] &amp;gt;= 0: x = dp[amt - coins[j]][j] y = 0 if j &amp;gt;= 1: y = dp[amt][j-1] dp[amt][j] = x + y return dp[amount][len(coins)-1] #Time Complexity: O(n*c), where c is amount #Space Complexity: O(n) class Solution: def change(self, amount: int, coins: List[int]) -&amp;gt; int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for amt in range(1, amount + 1): if amt &amp;gt;= coin: dp[amt] += dp[amt - coin] return dp[amount]</description></item><item><title>Number of Subsets</title><link>https://zalman0813.github.io/posts/number-of-subsets/</link><pubDate>Sun, 19 Mar 2023 20:00:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/number-of-subsets/</guid><description>Link: https://www.codingninjas.com/codestudio/problems/number-of-subsets_3952532?source=youtube&amp;amp;campaign=striver_dp_videos&amp;amp;utm_source=youtube&amp;amp;utm_medium=affiliate&amp;amp;utm_campaign=striver_dp_videos
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*s), where s is the target sum #Space Complexity: O(n*s) from os import * from sys import * from collections import * from math import * from typing import List def findWays(nums: List[int], target_sum: int) -&amp;gt; int: # Replace this placeholder return statement with your code tot = sum(nums) if tot &amp;lt; target_sum: return 0 dp = [ [0 for j in range(target_sum+1)] for i in range(len(nums))] # Base case 1 if nums[0] == 0: dp[0][0] = 2 # Base case 2 else: dp[0][0] = 1 if nums[0] &amp;lt;= target_sum: dp[0][nums[0]] = 1 for i in range(1, len(dp)): for required_sum in range(0, len(dp[0])): sum1 = 0 if nums[i] &amp;lt;= required_sum: sum1 = dp[i-1][required_sum - nums[i]] sum2 = dp[i-1][required_sum] dp[i][required_sum] = sum1 + sum2 return dp[len(nums)-1][target_sum]</description></item><item><title>1277. Count Square Submatrices With All Ones</title><link>https://zalman0813.github.io/posts/count-square-submatrices-with-all-ones/</link><pubDate>Sun, 19 Mar 2023 17:09:18 +0800</pubDate><guid>https://zalman0813.github.io/posts/count-square-submatrices-with-all-ones/</guid><description>Link: https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m) #Space Complexity: O(n*m) class Solution: def countSquares(self, nums: List[List[int]]) -&amp;gt; int: rows = len(nums) cols = len(nums[0]) dp = [ [0]*cols for i in range(rows) ] for i in range(rows): dp[i][0] = nums[i][0] for j in range(cols): dp[0][j] = nums[0][j] for i in range(1, rows): for j in range(1, cols): if nums[i][j] == 0: continue dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return sum([sum(row) for row in dp])</description></item><item><title>1891. Cutting Ribbons</title><link>https://zalman0813.github.io/posts/cutting-ribbons/</link><pubDate>Sun, 12 Mar 2023 22:15:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/cutting-ribbons/</guid><description>Link: https://leetcode.com/problems/cutting-ribbons/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*k), where k is sizes.length #Space Complexity: O(n) def count_ribbon_pieces(n, sizes): # create the array to store the results dp = [-1]*(n+1) dp[0] = 0 # calculate the results for all combinations # and select the maximum for i in range(1, n+1): for c in sizes: if i-c &amp;gt;= 0 and dp[i-c] != -1: dp[i] = max(dp[i], 1 + dp[i-c]) if dp[n] !</description></item><item><title>416. Partition Equal Subset Sum</title><link>https://zalman0813.github.io/posts/partition-equal-subset-sum/</link><pubDate>Sun, 12 Mar 2023 21:58:49 +0800</pubDate><guid>https://zalman0813.github.io/posts/partition-equal-subset-sum/</guid><description>Link: https://leetcode.com/problems/partition-equal-subset-sum/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m), where m = sum(nums) #Space Complexity: O(n) class Solution: def canPartition(self, nums: List[int]) -&amp;gt; bool: if sum(nums) % 2 != 0: return False target = sum(nums) // 2 dp = set() dp.add(0) for i in range(len(nums)-1, -1, -1): nextDp = set() for t in dp: if t + nums[i] == target: return True nextDp.add(t+nums[i]) nextDp.add(t) dp = nextDp return False</description></item><item><title>494. Target Sum</title><link>https://zalman0813.github.io/posts/target-sum/</link><pubDate>Sun, 12 Mar 2023 21:45:23 +0800</pubDate><guid>https://zalman0813.github.io/posts/target-sum/</guid><description>Link: https://leetcode.com/problems/target-sum/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m), where m = sum(nums) #Space Complexity: O(n) class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int: tot = sum(nums) if tot &amp;lt; abs(target): return 0 dp = [ [0 for j in range(2*tot + 1)] for i in range(len(nums))] dp[0][tot + nums[0]] = 1 dp[0][tot - nums[0]] += 1 for i in range(1, len(dp)): for t in range(-tot, tot+1): if dp[i-1][tot + t] &amp;gt; 0: dp[i][tot + t - nums[i]] += dp[i-1][tot + t] dp[i][tot + t + nums[i]] += dp[i-1][tot + t] return dp[len(nums) - 1][target + tot]</description></item><item><title>473. Matchsticks to Square</title><link>https://zalman0813.github.io/posts/matchsticks-to-square/</link><pubDate>Sun, 05 Mar 2023 23:26:52 +0800</pubDate><guid>https://zalman0813.github.io/posts/matchsticks-to-square/</guid><description>Link: https://leetcode.com/problems/matchsticks-to-square
Status: done
Solution: backtracking
Code:
#Time Complexity: O(4^n) #Space Complexity: O(n) class Solution: def makesquare(self, matchsticks: List[int]) -&amp;gt; bool: tot_length = sum(matchsticks) if tot_length % 4 != 0: return False length = tot_length / 4 sides = [0]*4 matchsticks.sort(reverse=True) def backtracking(i): if i == len(matchsticks): return True for j in range(4): if sides[j] + matchsticks[i] &amp;lt;= length: sides[j] += matchsticks[i] if backtracking(i+1): return True sides[j] -= matchsticks[i] return False return backtracking(0)</description></item><item><title>337. House Robber Iii</title><link>https://zalman0813.github.io/posts/house-robber-iii/</link><pubDate>Sun, 05 Mar 2023 08:20:19 +0800</pubDate><guid>https://zalman0813.github.io/posts/house-robber-iii/</guid><description>Link: https://leetcode.com/problems/house-robber-iii/
Status: done
Solution: backtracking
Code:
#Time Complexity: O(n) #Space Complexity: O(h), , where h is the height of the tree # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def dfs(self, root): if root is None: return [0, 0] leftChild = self.dfs(root.left) rightChild = self.dfs(root.right) not_node = max(leftChild) + max(rightChild) node = root.</description></item><item><title>93. Restore Ip Addresses</title><link>https://zalman0813.github.io/posts/restore-ip-addresses/</link><pubDate>Sun, 05 Mar 2023 08:16:16 +0800</pubDate><guid>https://zalman0813.github.io/posts/restore-ip-addresses/</guid><description>Link: https://leetcode.com/problems/restore-ip-addresses/
Status: done
Solution: backtracking
Code:
#Time Complexity: O(1) #Space Complexity: O(1) class Solution: def restoreIpAddresses(self, s: str) -&amp;gt; List[str]: if len(s) &amp;lt; 4 or len(s) &amp;gt; 12: return [] result = [] def backtracking(i, dots, curIp): if dots == 4 and i == len(s): result.append(curIp[:-1]) return if dots &amp;gt; 4: return for j in range(i, min(i+3,len(s))): if int(s[i:j+1]) &amp;lt;= 255 and (i == j or s[i] != &amp;#39;0&amp;#39;): backtracking(j+1, dots + 1, curIp + s[i:j+1] + &amp;#34;.</description></item><item><title>79. Word Search</title><link>https://zalman0813.github.io/posts/word-search/</link><pubDate>Sun, 05 Mar 2023 08:06:48 +0800</pubDate><guid>https://zalman0813.github.io/posts/word-search/</guid><description>Link: https://leetcode.com/problems/word-search/
Status: done
Solution: backtracking
Code:
#Time Complexity: O(n√ó3^l) #Space Complexity: O(l), , where l is the length of the word to be searched in the grid. class Solution: def word_search(self, grid, word): n = len(grid) if n &amp;lt; 1: return False m = len(grid[0]) if m &amp;lt; 1: return False for row in range(n): for col in range(m): if self.depth_first_search(row, col, grid, word): return True return False def depth_first_search(self,row, col, grid, word): if len(word) == 0: return True if row &amp;lt; 0 or row == len(grid) or col &amp;lt; 0 or col == len(grid[0]) \ or word[0].</description></item><item><title>55. Jump Game I</title><link>https://zalman0813.github.io/posts/jump-game-i/</link><pubDate>Sun, 26 Feb 2023 22:00:30 +0800</pubDate><guid>https://zalman0813.github.io/posts/jump-game-i/</guid><description>Link: https://leetcode.com/problems/jump-game/
Solution: greedy
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: end = len(nums) - 1 for i in range(len(nums) - 2, -1, -1): if i + nums[i] &amp;gt;= end: end = i if end == 0: return True return False</description></item><item><title>881. Boats to Save People</title><link>https://zalman0813.github.io/posts/boats-to-save-people/</link><pubDate>Sun, 26 Feb 2023 22:00:13 +0800</pubDate><guid>https://zalman0813.github.io/posts/boats-to-save-people/</guid><description>Link: https://leetcode.com/problems/boats-to-save-people/description/
Solution: greedy
# Time Complexity: O(nlogn) # Space Complexity: O(n), n represents the memory required to sort this array. class Solution: def numRescueBoats(self, people: List[int], limit: int) -&amp;gt; int: people.sort() l = 0 r = len(people) - 1 boats = 0 while l &amp;lt;= r: if people[l] + people[r] &amp;lt;= limit: l += 1 r -= 1 boats += 1 return boats</description></item><item><title>134. Gas Station</title><link>https://zalman0813.github.io/posts/gas-station/</link><pubDate>Sun, 26 Feb 2023 21:59:51 +0800</pubDate><guid>https://zalman0813.github.io/posts/gas-station/</guid><description>Link: https://leetcode.com/problems/gas-station/
Solution: greedy
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&amp;gt; int: if sum(gas) &amp;lt; sum(cost): return -1 start = 0 total = 0 for i in range(len(gas)): total += gas[i] - cost[i] if total &amp;lt; 0: start = i + 1 total = 0 return start</description></item><item><title>1029. Two City Scheduling</title><link>https://zalman0813.github.io/posts/two-city-scheduling/</link><pubDate>Sun, 26 Feb 2023 21:56:28 +0800</pubDate><guid>https://zalman0813.github.io/posts/two-city-scheduling/</guid><description>Link: https://leetcode.com/problems/two-city-scheduling/
Solution: greedy
# Time Complexity: O(nlogn) # Space Complexity: O(m + n), m represents the memory required to sort this array. # Python uses a combination of merge sort and insertion sort which can sort the array in O(m) class Solution: def twoCitySchedCost(self, costs: List[List[int]]) -&amp;gt; int: diff = [] for costa, costb in costs: diff.append([costa - costb, costa, costb]) diff.sort() result = 0 tot = len(costs) for i in range(tot): if i &amp;gt;= tot / 2: result += diff[i][2] else: result += diff[i][1] return result</description></item><item><title>45. Jump Game Ii</title><link>https://zalman0813.github.io/posts/jump-game-ii/</link><pubDate>Sun, 26 Feb 2023 21:38:00 +0800</pubDate><guid>https://zalman0813.github.io/posts/jump-game-ii/</guid><description>Link: https://leetcode.com/problems/jump-game-ii/description/
Solution: greedy
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def jump(self, nums: List[int]) -&amp;gt; int: l = r = 0 times = 0 while r &amp;lt; len(nums) - 1: farthest = 0 for i in range(l, r + 1): farthest = max(farthest, i+nums[i]) l = r + 1 r = farthest times += 1 return times</description></item><item><title>81. Search in Rotated Sorted Array Ii</title><link>https://zalman0813.github.io/posts/search-in-rotated-sorted-array-ii/</link><pubDate>Sun, 19 Feb 2023 17:43:27 +0800</pubDate><guid>https://zalman0813.github.io/posts/search-in-rotated-sorted-array-ii/</guid><description>Link: https://leetcode.com/problems/search-in-rotated-sorted-array-ii
Solution: binary search
# Time Complexity: O(log(n)) # Space Complexity: O(1) class Solution: def search(self, nums: List[int], target: int) -&amp;gt; bool: if len(nums) == 1: if nums[0] == target: return True else: return False l, r = 0, len(nums) - 1 while l &amp;lt;= r: # shifting to remove duplicate elements while l&amp;lt;r and nums[l] == nums[l+1]: l+=1 while l&amp;lt;r and nums[r] == nums[r-1]: r-=1 mid = (l + r) // 2 if target == nums[mid]: return True if nums[l] &amp;lt;= nums[mid]: if target &amp;gt;= nums[l] and target &amp;lt; nums[mid]: r = mid - 1 else: l = mid + 1 else: if target &amp;gt; nums[mid] and target &amp;lt;= nums[r]: l = mid + 1 else: r = mid - 1 return False</description></item><item><title>540. Single Element in a Sorted Array</title><link>https://zalman0813.github.io/posts/single-element-in-a-sorted-array/</link><pubDate>Sun, 19 Feb 2023 17:17:20 +0800</pubDate><guid>https://zalman0813.github.io/posts/single-element-in-a-sorted-array/</guid><description>Link: https://leetcode.com/problems/single-element-in-a-sorted-array/
Solution: binary search
# Time Complexity: O(log(n)) # Space Complexity: O(1) class Solution: def singleNonDuplicate(self, nums: List[int]) -&amp;gt; int: l, r = 0, len(nums) - 1 while l &amp;lt; r: m = l + (r-l)//2 # use the pair arrangement propert. even is equalt to next odd until an unpaired number appears, # If the element at mid and mid + 1 are the same then # the single element must appear after the mid point # Otherwise we must search before the mid point if m % 2 == 1: m -= 1 # to preceding even index if nums[m] == nums[m + 1]: l = m + 2 else: r = m return nums[l]</description></item><item><title>528. Random Pick With Weight</title><link>https://zalman0813.github.io/posts/random-pick-with-weight/</link><pubDate>Sun, 19 Feb 2023 17:05:57 +0800</pubDate><guid>https://zalman0813.github.io/posts/random-pick-with-weight/</guid><description>Link: https://leetcode.com/problems/random-pick-with-weight/
Solution: binary search
# Time Complexity: # 1. Construct: O(n) # 2. pickIndex: o(logn) # Space Complexity: # 1. Construct: O(n) # 2. pickIndex: O(1) class Solution: def __init__(self, w: List[int]): self.cum_sums = [] cum = 0 for i in range(len(w)): cum += w[i] self.cum_sums.append(cum) def pickIndex(self) -&amp;gt; int: target = random.randint(1, self.cum_sums[-1]) # Assigning low pointer at the start of the array low = 0 # Assigning high pointer at the end of the array high = len(self.</description></item><item><title>658. Find K Closest Elements</title><link>https://zalman0813.github.io/posts/find-k-closest-elements/</link><pubDate>Sun, 19 Feb 2023 16:44:39 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-k-closest-elements/</guid><description>Link: https://leetcode.com/problems/find-k-closest-elements/description/
Solution: binary search
# Time Complexity: O(log(n-k)) # Space Complexity: O(1) class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -&amp;gt; List[int]: l, r = 0, len(arr) - k while l &amp;lt; r: m = l + (r - l) // 2 if x - arr[m] &amp;gt; arr[m+k] - x: l = m + 1 else: r = m return arr[l:l+k]</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://zalman0813.github.io/posts/kth-largest-element-in-an-array/</link><pubDate>Mon, 13 Feb 2023 09:27:14 +0800</pubDate><guid>https://zalman0813.github.io/posts/kth-largest-element-in-an-array/</guid><description>Link: https://leetcode.com/problems/kth-largest-element-in-an-array/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(k) import heapq class Solution: def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int: # your code will replace this placeholder return statement minHeap = [] for i in range(len(nums)): if len(minHeap) == k: if minHeap[0] &amp;lt; nums[i]: heappop(minHeap) heappush(minHeap, nums[i]) else: heappush(minHeap, nums[i]) return minHeap[0]</description></item><item><title>347. Top K Frequent Elements</title><link>https://zalman0813.github.io/posts/top-k-frequent-elements/</link><pubDate>Sun, 12 Feb 2023 16:56:14 +0800</pubDate><guid>https://zalman0813.github.io/posts/top-k-frequent-elements/</guid><description>Link: https://leetcode.com/problems/top-k-frequent-elements/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(n+k) from collections import Counter import heapq class Solution: def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]: num_freq = Counter(nums) minHeap = [] for num, count in num_freq.items(): if len(minHeap) == k: if count &amp;gt; minHeap[0][0]: heapq.heappop(minHeap) heapq.heappush(minHeap, (count, num)) else: heapq.heappush(minHeap, (count, num)) return [ num for count, num in minHeap ]</description></item><item><title>973. K Closest Points to Origin</title><link>https://zalman0813.github.io/posts/k-closest-points-to-origin/</link><pubDate>Sun, 12 Feb 2023 16:14:53 +0800</pubDate><guid>https://zalman0813.github.io/posts/k-closest-points-to-origin/</guid><description>Link: https://leetcode.com/problems/k-closest-points-to-origin/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(k) import heapq class Solution: def kClosest(self, points: List[List[int]], K: int) -&amp;gt; List[List[int]]: maxHeap = [] for (x, y) in points: if len(maxHeap) == K: head_x = maxHeap[0][1][0] head_y = maxHeap[0][1][1] if self.distance(x, y) &amp;lt; self.distance(head_x, head_y): heapq.heappop(maxHeap) heapq.heappush(maxHeap, [-self.distance(x, y), (x, y)]) else: heapq.heappush(maxHeap, [-self.distance(x, y), (x, y)]) return [[point[0], point[1]] for dist, point in maxHeap] def distance(self, x, y): return (x*x + y*y)</description></item><item><title>767. Reorganize String</title><link>https://zalman0813.github.io/posts/reorganize-string/</link><pubDate>Sun, 12 Feb 2023 15:16:54 +0800</pubDate><guid>https://zalman0813.github.io/posts/reorganize-string/</guid><description>Link: https://leetcode.com/problems/reorganize-string/
Solution: top k elements
Code:
# Time Complexity: O(nlogc). Due to c bounded by the size of the alphabet, space is O(n). # Space Complexity: O(c). Due to c bounded by the size of the alphabet, space is O(1). from collections import Counter import heapq class Solution: def reorganizeString(self, s: str) -&amp;gt; str: char_counter = Counter(s) most_freq_chars = [] for char, freq in char_counter.items(): heapq.heappush(most_freq_chars, [-freq, char]) result = &amp;#34;&amp;#34; previous = None while len(most_freq_chars) &amp;gt; 0: count, char = heapq.</description></item><item><title>417. Pacific Atlantic Water Flow</title><link>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</link><pubDate>Sun, 05 Feb 2023 23:33:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</guid><description>Link: https://leetcode.com/problems/pacific-atlantic-water-flow/
Solution: dfs
Code: dfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def pacificAtlantic(self, heights: List[List[int]]) -&amp;gt; List[List[int]]: pac = set() atl = set() ROWS = len(heights) COLS = len(heights[0]) def dfs(r, c, visit, prevHeight): if ((r, c) in visit or r &amp;lt; 0 or c &amp;lt; 0 or r &amp;gt;= ROWS or c &amp;gt;= COLS or heights[r][c] &amp;lt; prevHeight ): return visit.add((r,c)) dfs(r + 1, c, visit, heights[r][c]) dfs(r - 1, c, visit, heights[r][c]) dfs(r, c + 1, visit, heights[r][c]) dfs(r, c - 1, visit, heights[r][c]) for c in range(COLS): dfs(0, c, pac, heights[0][c]) dfs(ROWS - 1, c, atl, heights[ROWS - 1][c]) for r in range(ROWS): dfs(r, 0, pac, heights[r][0]) dfs(r, COLS - 1, atl, heights[r][COLS-1]) res = [] for r in range(ROWS): for c in range(COLS): if (r, c) in pac and (r, c) in atl: res.</description></item><item><title>1730. Shortest Path to Get Food</title><link>https://zalman0813.github.io/posts/shortest-path-to-get-food/</link><pubDate>Sun, 05 Feb 2023 23:28:13 +0800</pubDate><guid>https://zalman0813.github.io/posts/shortest-path-to-get-food/</guid><description>Link: https://leetcode.com/problems/shortest-path-to-get-food/
Solution: bfs
Code: bfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def getFood(self, grid): ROWS, COLS = len(grid), len(grid[0]) visit, queue = set(), collections.deque() for r in range(ROWS): for c in range(COLS): if grid[r][c] == &amp;#39;*&amp;#39;: queue.append((r,c, 0)) visit.add((r,c)) break directions = [(1,0),(0,-1), (-1,0), (0,1)] while queue: cur_r, cur_c, steps = queue.popleft() if grid[cur_r][cur_c] == &amp;#39;#&amp;#39;: return steps else: for dr,dc in directions: new_r, new_c = r + dr, c + dc if (0&amp;lt;=new_r&amp;lt;ROWS) and (0&amp;lt;=new_c&amp;lt;COLS) and grid[new_r][new_c] !</description></item><item><title>373. Find K Pairs With Smallest Sums</title><link>https://zalman0813.github.io/posts/find-k-pairs-with-smallest-sums/</link><pubDate>Sun, 05 Feb 2023 21:28:17 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-k-pairs-with-smallest-sums/</guid><description>Link: https://leetcode.com/problems/find-k-pairs-with-smallest-sums
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(mlogm + klogm) -&amp;gt; (m + k)logm # Space Complexity: O(m), where m = min(k, n1) class Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&amp;gt; List[List[int]]: result = [] minHeap = [] # pop &amp;amp; push for i in range(min(k,len(nums1))): heappush(minHeap, (nums1[i]+nums2[0], i, 0)) counter = 1 while counter &amp;lt;= k and minHeap: _, i1, i2 = heappop(minHeap) result.</description></item><item><title>378. Kth Smallest Element in a Sorted Matrix</title><link>https://zalman0813.github.io/posts/kth-smallest-element-in-a-sorted-matrix/</link><pubDate>Fri, 03 Feb 2023 22:34:00 +0800</pubDate><guid>https://zalman0813.github.io/posts/kth-smallest-element-in-a-sorted-matrix/</guid><description>Link: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(nlogn+(klogn))=O((n+k)logn) # Space Complexity: O(n*n) class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -&amp;gt; int: # TODO: Write your code here minHeap = [] # firstly, insert (first elemetn of list, index of fist element, list) for l in matrix: heappush(minHeap, (l[0], 0, l)) for _ in range(k - 1): value, index, l = heappop(minHeap) index += 1 if index &amp;lt; len(l): heappush(minHeap, (l[index], index, l)) value, _, _ = heappop(minHeap) return value</description></item><item><title>199. Binary Tree Right Side View</title><link>https://zalman0813.github.io/posts/binary-tree-right-side-view/</link><pubDate>Sat, 14 Jan 2023 22:24:32 +0800</pubDate><guid>https://zalman0813.github.io/posts/binary-tree-right-side-view/</guid><description>Link: https://leetcode.com/problems/binary-tree-maximum-path-sum
Solution: dfs Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right from collections import deque class Solution: def rightSideView(self, root: Optional[TreeNode]) -&amp;gt; List[int]: if not root: return [] result = [] q = deque() q.append(root) while q: for i in range(len(q)): curNode = q.</description></item><item><title>457. Circular Array Loop</title><link>https://zalman0813.github.io/posts/circular-array-loop/</link><pubDate>Sun, 08 Jan 2023 17:27:02 +0800</pubDate><guid>https://zalman0813.github.io/posts/circular-array-loop/</guid><description>Link: https://leetcode.com/problems/rotate-list
Solution: slow-fast Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(n) class Solution: def circularArrayLoop(self, arr: List[int]) -&amp;gt; bool: #remember all the numbers that have been visited visited = set() for i in range(len(arr)): if i in visited: continue is_forward = arr[i] &amp;gt;= 0 # if we are moving forward or not slow, fast = i, i # if slow or fast becomes &amp;#39;-1&amp;#39; this means we can&amp;#39;t find cycle for this number while True: # move one step for slow pointer slow = self.</description></item><item><title>61. Rotate List</title><link>https://zalman0813.github.io/posts/rotate-list/</link><pubDate>Sun, 08 Jan 2023 16:44:33 +0800</pubDate><guid>https://zalman0813.github.io/posts/rotate-list/</guid><description>Link: https://leetcode.com/problems/rotate-list
Solution: linked-list
Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def rotateRight(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: if k &amp;lt;= 0 or not head: return head # find last node and length last_node = head list_length = 1 while last_node.next: last_node = last_node.</description></item><item><title>92. Reverse Linked List Ii</title><link>https://zalman0813.github.io/posts/reverse-linked-list-ii/</link><pubDate>Sun, 08 Jan 2023 14:29:47 +0800</pubDate><guid>https://zalman0813.github.io/posts/reverse-linked-list-ii/</guid><description>Link: https://leetcode.com/problems/reverse-linked-list-ii
Solution: in-place reversal of a linkedlist
Code:
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&amp;gt; Optional[ListNode]: if left == right: return head # after skipping &amp;#39;left-1&amp;#39; nodes, current will point to &amp;#39;left&amp;#39;th node prev, cur = None, head i = 0 while cur and i &amp;lt; left - 1: prev, cur = cur, cur.</description></item><item><title>235. Lowest Common Ancestor of a Binary Search Tree</title><link>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</link><pubDate>Fri, 11 Nov 2022 23:20:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</guid><description>Link: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
Status: done
Solution: binary search, dfs, recursive
Code:
binary search # Time Complexity: O(LogN) # Space Complexity: O(1) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: cur = root while cur: if cur.val &amp;gt; p.val and cur.val &amp;gt; q.val: cur = cur.left elif cur.val &amp;lt; p.val and cur.val &amp;lt; q.val: cur = cur.right else: return cur dfs - without binary search info - &amp;ldquo;236. Lowest Common Ancestor of a Binary Tree&amp;rdquo; # Time Complexity: O(LogN) # Space Complexity: O(LogN) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: if root == p or root == q or not root: return root left = self.</description></item></channel></rss>